package transport;

public class DamagedRover extends MarsRover
{
	private final static int		MAX_TRAVEL_METERS_BEFORE_EMPTY_BATTERY	= 10000;
	private final static int		METERS_FROM_START_TO_CLIFF				=  1000;
	private final static int		N_SIMULATIONS							=  5000;

	private double 					position;
	private double					metersTraveled;
	private boolean					fell;


    //    // Simulates travel under damage conditions. In each turn, travels forward or    // backward either 1, 2, 3, or 4 meters. Continues until there's no more power    // in the battery, or we fall off a cliff. Cliffs are at position = 1000 or    // position = -1000.    //    public void simulateStormDamageTravel() {        position = 0;
        while (metersTraveled < MAX_TRAVEL_METERS_BEFORE_EMPTY_BATTERY) {            int doubledistanceNextTurn = (int)(1 + 4 * Math.random());
            boolean booleanforwardNotBack = (Math.random() > 0.5);            // Adjust position and metersTraveled.            // Check for falling off cliff. }
        }    }


	public double getMetersTraveled()
	{
		return this.metersTraveled;
	}


	public boolean getFell()
	{
		return this.fell;
	}


	public static void main(String[] args)
	{
		System.out.println("START");

		int nFalls = 0;
		double totalMetersBeforeFalling = 0;

		for (int i = 0; i < 100; i++)
		{
            System.out.println("START");
			DamagedRover rover = new DamagedRover();
			rover.simulateStormDamageTravel();
			if (rover.getFell())
			{
				// Fell.
				nFalls++;
				totalMetersBeforeFalling += rover.getMetersTraveled();
			}
		}

		double averageMetersBeforeFalling = totalMetersBeforeFalling / nFalls;
		System.out.println("Average distance before falling = " + averageMetersBeforeFalling);

	}
}
